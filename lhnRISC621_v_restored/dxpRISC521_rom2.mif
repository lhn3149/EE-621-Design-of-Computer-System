-- Memory File
-- Test Program 2 for CPU test
-- This program reads in two 4-bit numbers,
--    multiplies these, and then displays the 8-bit product.

WIDTH = 4;
DEPTH = 256;

ADDRESS_RADIX = HEX;	% Can be HEX, BIN or DEC %
DATA_RADIX = HEX;	% Can be HEX, BIN or DEC %

CONTENT BEGIN
-- Initialize register A to 0
-- Need to do this even though the first time around through the
--     program it is actually 0 due to the reset.
0	:	B; % CPY - OpCode %
1	:	1; % SUB - OpCode %
-- This INC creates the constant value 0001
2	:	2; % INC - OpCode %
-- The value 0001 is used to keep track which operand is
--    being read.  Its value is stored in the Read_Count_Variable
3	:	C; % WR - OpCode - Read_Count_Variable = 0011 %
4	:	5; % WR - MAH - Read_Count_Variable %
5	:	0; % WR - MAL -    address is 0x50 %
-- The user sets the value of the first operand on the switches.
-- Then, it presses and depresses the PB.  The next code sequence
--    detects the state of the PB:
--    depressed (1) --> pressed (0) --> depressed (1)
6	:	E; % IN - OpCode - Check if PB is still 1 = depressed %
7	:	1; % IN - MAH - PB %
8	:	4; % NOT - OpCode %
9	:	7; % SHR - OpCode %
A	:	9; % JMPC - OpCode - If PB=1 check again %
B	:	0; % JMPC - MAH/PCH %
C	:	6; % JMPC - MAL/PCL %
D	:	E; % IN - OpCode - Check if PB is still 0 = pressed %
E	:	1; % IN - MAH - PB %
F	:	7; % SHR - OpCode %
10	:	9; % JMPC - OpCode - If PB=0 check again %
11	:	0; % JMPC - MAH/PCH %
12	:	D; % JMPC - MAL/PCL %
-- Now read back from the memory the Read_Count_Variable
--    and determine if the value set on the switches is
--    that of the 1st or 2nd operand.
13	:	D; % RD - OpCode - Read_Count_Variable %
14	:	5; % RD - MAH Read_Count_Variable %
15	:	0; % RD - MAL    address is 0x50%
16	:	7; % SHR - OpCode %
17	:	C; % WR - OpCode %
18	:	5; % WR MAH - Read_Count_Variable %
19	:	0; % WR MAL -    address is 0x50 %
1A	:	9; % JMPC - OpCode %
1B	:	2; % JMPC - MAH/PCH %
1C	:	5; % JMPC - MAL/PCL %
-- Read from the switches the value of the 1st operand,
--    say the Multiplicand.  Store it in memory.
1D	:	E; % IN - OpCode %
1E	:	0; % IN - MAH - SW %
1F	:	C; % WR - OpCode - Multiplicand_variable %
20	:	5; % WR - MAH - Multiplicand_variable %
21	:	1; % WR - MAL - address is 0x51 %
-- Jump unconditionally to check again for the PB,
--    so that you read the 2nd operand.
22	:	8; % JMPU - OpCode %
23	:	0; % JMPU - MAH/PCH %
24	:	6; % JMPU - MAL/PCL %
-- Read from the switches the value of the 2nd operand,
--    say the Multiplicand.  Store it in memory.
25	:	E; % IN - OpCode %
26	:	0; % IN - MAH - SW %
27	:	C; % WR - OpCode - Multiplier_variable %
28	:	5; % WR - MAH - Multiplier_variable %
29	:	2; % WR - MAL - address is 0x52 %
-- Here starts the actual multiplication portion of the code
-- The multiplication of two 4-bit numbers results in a 
--    product at most 8-bits wide.  This has to be stored
--    using two 4-bit locations: one for Product_high
--    and one for Product_low.
2A	:	B; % CPY - OpCode %
2B	:	1; % SUB - OpCode %
2C	:	C; % WR - OpCode - Product_high_variable initialized to 0%
2D	:	5; % WR - MAH - Product_high_variable %
2E	:	3; % WR - MAL - address is 0x53 %
-- Product_low is stored in register B during the multiplication
--    loop.
2F	:	B; % CPY - OpCode - Product_low_variable initialized to 0 in RegB %
30	:	D; % RD - OpCode - Multiplier_Variable = LOOP %
31	:	5; % RD - MAH %
32	:	2; % RD - MAL %
-- The algorithm adds the original value of the multiplicand
--    multiplier times to the (partial) product.
33	:	3; % DEC - OpCode %	 
34	:	C; % WR	- OpCode - Multiplier_Variable %
35	:	5; % WR - MAH %
36	:	2; % WR - MAL %
-- If the current multiplier value is 0, we are done adding
--    the original multiplicand to the (partial) product.
37	:	9; % JMPC - OpCode - TO DONE address that is 0x4C %
38	:	4; % JMPC - MAH/PCH %
39	:	C; % JMPC - MAL/PCL %
-- If the current multiplier value is not 0, read the
--    original multiplicand value and add it to the current
--    Product_low_variable (stored in register B).
3A	:	D; % RD	- OpCode - Multiplicand_variable %
3B	:	5; % RD - MAH %
3C	:	1; % RD - MAL %
3D	:	0; % ADD - OpCode %
3E	:	B; % CPY - OpCode %
-- If the Carry=1, we have to increment Product_high_variable
-- Else jump to the beginning of the loop again.
3F	:	9; % JMPC - OpCode - TO LOOP address that is 0x30 %
40	:	3; % JMPC - MAH/PCH %
41	:	0; % JMPC - MAL/PCL %
-- Increment Product_high_variable
42	:	D; % RD	- OpCode - Product_high_variable %
43	:	5; % RD - MAH %
44	:	3; % RD - MAL %
45	:	2; % INC %
46	:	C; % WR	- OpCode - Product_high_variable %
47	:	5; % WR - MAH %
48	:	3; % WR - MAL %
-- Jump unconditionally to the beginning of the loop
49	:	8; % JMPU - OpCode - TO LOOP address that is 0x30 %
4A	:	3; % JMPU - MAH/PCH %
4B	:	0; % JMPU - MAL/PCL %
-- The program arrives at this point if it has completed
--    the multiplication (loop).
-- Now write out Product_high and low to the respective
--    displays.
4C	:	A; % SWAP - OpCode = DONE %
4D	:	F; % OUT - OpCode - display_low/right %
4E	:	3;
4F	:	D; % RD	- OpCode - Product_high_variable %
50	:	5; % RD - MAH %
51	:	3; % RD - MAL %
52	:	F; % OUT - OpCode - display_high/left %
53	:	2;
-- Jump to the beginning of the program and wait for another 
--    two values to multiply.
54	:	8; % JMPU - OpCode - Start %
55	:	0; % JMPU - MAH/PCH %
56	:	0; % JMPU - MAL/PCL %
END;